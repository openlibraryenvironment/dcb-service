buildscript {
	repositories {
		mavenCentral()
	}
}

plugins {
	id("com.github.johnrengelman.shadow") version "7.1.2"
	id("io.micronaut.application") version "3.7.0"
	id("io.micronaut.test-resources") version "3.7.0"
	id('jacoco')
	id 'org.olf.reshare.dcb-bom'
	id 'service.k_int.micronaut-multi'
}

//configurations.all {
//	resolutionStrategy.dependencySubstitution {
//		substitute(module("io.micronaut:micronaut-jackson-databind"))
//				.using(module("io.micronaut.serde:micronaut-serde-jackson:1.3.2"))
//	}
//}

//version = "0.1"
group = "org.olf.reshare.dcb"

repositories {
	mavenCentral()
}


dependencies {
	// This should likely always be first in the annotations list
	annotationProcessor('org.immutables:value')
	annotationProcessor('io.micronaut:micronaut-graal')
	annotationProcessor("io.micronaut.serde:micronaut-serde-processor")
	annotationProcessor("io.micronaut:micronaut-http-validation")
	annotationProcessor("io.micronaut.openapi:micronaut-openapi")
	annotationProcessor('io.micronaut.security:micronaut-security-annotations')
	annotationProcessor("io.micronaut.data:micronaut-data-processor")

	// Implementation
	implementation("io.micronaut.security:micronaut-security-jwt")
	implementation("io.micronaut:micronaut-http-client")
	implementation("io.micronaut:micronaut-management")
	implementation("io.micronaut.cache:micronaut-cache-caffeine")
	//    implementation("io.micronaut.elasticsearch:micronaut-elasticsearch")
	implementation("io.micronaut.reactor:micronaut-reactor")
	implementation("io.micronaut.reactor:micronaut-reactor-http-client")
	implementation("io.swagger.core.v3:swagger-annotations")
	implementation("jakarta.annotation:jakarta.annotation-api")
	implementation("io.micronaut:micronaut-validation")

	implementation("org.apache.logging.log4j:log4j-api")
	implementation("org.apache.logging.log4j:log4j-core")

	//	implementation("io.micronaut:micronaut-jackson-databind") // Not using Jackson for binding.
	implementation("io.micronaut.serde:micronaut-serde-jackson")
	implementation 'org.marc4j:marc4j'

	runtimeOnly("ch.qos.logback:logback-classic")
	runtimeOnly("org.slf4j:log4j-over-slf4j")

	compileOnly('org.immutables:value')
	compileOnly("org.graalvm.nativeimage:svm")

	//data
	implementation("io.micronaut.r2dbc:micronaut-r2dbc-core")
	implementation("io.micronaut.data:micronaut-data-processor")
	implementation("io.micronaut.data:micronaut-data-r2dbc")
	implementation("io.micronaut.data:micronaut-data-jdbc")
	implementation("io.micronaut.sql:micronaut-jdbc-hikari")

	runtimeOnly("org.postgresql:postgresql")
	// Without this dependency, testcontainer injection seems not to happen at all.
	// Wonder if this is because the bean that uses PG is a r2dbc service
	runtimeOnly("org.postgresql:r2dbc-postgresql")

	// Uncommmenting this dependency results in
	// testresources Micronaut Message: Could not resolve placeholder ${auto.test.resources.r2dbc.datasources.default.options.protocol}
	//
	runtimeOnly("io.r2dbc:r2dbc-pool")


	// The postgres r2dbc driver seems much more recent - so commenting this one out, and testing
	// runtimeOnly('io.r2dbc:r2dbc-postgresql')

	implementation("io.micronaut.flyway:micronaut-flyway")

	// Tests

	testImplementation("io.micronaut.test:micronaut-test-junit5")
	testImplementation('org.mock-server:mockserver-junit-jupiter')
	testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")

	testImplementation(platform("org.testcontainers:testcontainers-bom:1.14.3"))
	testRuntimeOnly("org.testcontainers:postgresql")
}

//configurations.all {
//	resolutionStrategy.dependencySubstitution {
//		substitute(module("io.micronaut:micronaut-jackson-databind"))
//				.using(module("io.micronaut.serde:micronaut-serde-jackson:1.5.0"))
//	}
//}

application {
	mainClass.set("org.olf.reshare.dcb.Application")
}

run {
	systemProperties([
		'micronaut.environments': 'development'
	])
}

java {
	sourceCompatibility = JavaVersion.toVersion("17")
	targetCompatibility = JavaVersion.toVersion("17")
}

graalvmNative.toolchainDetection = false
micronaut {
	runtime("netty")
	testRuntime("junit5")
	processing {
		incremental(true)
		annotations("org.olf.reshare.dcb.*")
	}
}

final Set<String> jacocoExcludes = ['**/Application.class']

tasks {


	final Map<String, String> labels = [
		'maintainer': 'Steve Osguthorpe <steve.osguthorpe@k-int.com>',
		'version'   : project.hasProperty('versionWithMeta') ? project.getProperty('versionWithMeta') : project.getProperty('version')
	]

	dockerfile {
		label(labels)
	}

	dockerfileNative {
		label(labels)
	}

	boolean isPre = project.hasProperty('versionPreRelease') &&
		("${project.getProperty('versionPreRelease')}".trim() != "")

	// Build up a list of tags we should apply
	final Set<String> tags = [
		'versionMajor',
		'versionMajorMinor',
		'version'
	].findResults {
		(project.hasProperty(it) && !project.property(it).equals('unspecified')) ? project.property(it).toString().trim() : null
	}

	// If this is a pre-release (including Snapshots) then add "next" tag. Otherwise, use latest
	tags << (isPre ? 'next' : 'latest')

	final imageAndRepo = "${System.env.DOCKER_IMAGE ?: project.name}"

	Set<String> imageNames = tags.collect { "${imageAndRepo}:${it}" }

	dockerBuild {
		images = imageNames
	}

	dockerBuildNative {
		images = imageNames
	}

	jacocoTestReport {
		dependsOn test

		reports {
			xml.enabled false
			csv.enabled false
		}

		afterEvaluate {
			classDirectories.setFrom(files(classDirectories.files.collect {
				fileTree(dir: it, exclude: jacocoExcludes)
			}))
		}
	}
	jacocoTestCoverageVerification {

		afterEvaluate {
			classDirectories.setFrom(files(classDirectories.files.collect {
				fileTree(dir: it, exclude: jacocoExcludes)
			}))
		}

		violationRules {
			rule {
				limit {
					minimum = 0.7 // 70% coverage
				}
			}
		}
	}
}
